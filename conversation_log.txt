SECTION 1 - PROMPT 1

My prompt:
“The pseudocode for Section 1.1 is as follows:
Design a CLI Task Manager that lets the user add, list, and remove tasks.
Please help me write Section 1.2, which requires two prompt refinements.”

AI RESPONSE:
AI proposed two refinements for the original pseudocode:

Added explicit planning for validation and structured menu control based on Week 4–6 course logic.

Improved pseudocode layout with proper indentation, parameterized functions, and menu iteration loop.
AI also explained that the refinement demonstrates iterative improvement similar to the Week 9 “refinement cycle” approach.

COURSE CONSTRAINT CHECK:
AI’s initial draft suggested more advanced syntax; I simplified it to use only lists, loops, and simple functions, consistent with Week 6 functional programming limits.


SECTION 1 - PROMPT 2

My prompt:
“Please refine my Section 1.2 version again. Use only content taught from Week 1–10.”

AI RESPONSE:
AI refined the prompt text for greater specificity. It added requirements to validate user input, show clearer structure for function interactions, and ensure menu persistence until the user chooses Quit. It applied Week 5–6 iterative structure and Week 8-style validation consistency.

COURSE CONSTRAINT CHECK:
Removed AI’s suggestions about importing modules or using external file storage; final pseudocode remained fully in-memory, aligned with Week 4–6 tools.


SECTION 2 - PROMPT 1

My prompt:
“Here is the buggy code for the Task Manager (broken_task_manager.py). Please identify all errors and explain them clearly.”

AI RESPONSE:
AI identified six issues:
Typo fix: len(tas) → len(tasks)
Add range validation: if 0 <= index < len(tasks)
Move removed = tasks[index] inside validation
Correct iteration: for i, t in enumerate(tasks)
Correct function call: list_task() → list_tasks()
Keep consistent output messages for invalid or empty lists
AI provided detailed “where” and “why” reasoning for each fix.

COURSE CONSTRAINT CHECK:
Followed Week 6 debugging methods—only print and condition-based fixes, no exception or logging modules.


SECTION 2 - PROMPT 2

My prompt:
“This is my corrected code version. Please check if the fixes are correct.”

AI RESPONSE:
AI reviewed and confirmed that all six errors were corrected. It restated the revised code:

tasks = []

def add_task(task):
    tasks.append(task)
    print(f"Added: {task}")

def remove_task(index):
    if 0 <= index < len(tasks):
        removed = tasks[index]
        del tasks[index]
        print(f"Removed: {removed}")
    else:
        print("Invalid index!")

def list_tasks():
    if not tasks:
        print("No tasks available.")
    else:
        for i, t in enumerate(tasks):
            print(f"{i+1}: {t}")

def main():
    add_task("Buy milk")
    add_task("Pay bills")
    add_task("Walk dog")
    list_tasks()
    remove_task(1)
    list_tasks()

if __name__ == "__main__":
    main()

AI confirmed the version is syntactically correct and fully resolves the six detected issues.

COURSE CONSTRAINT CHECK:
Ensured the solution used only print outputs and in-memory data, consistent with Week 6 lab debugging style.

